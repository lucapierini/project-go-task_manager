// models/User.go
package models

import (
    "gorm.io/gorm"
)

type User struct {
    gorm.Model
    Username string `gorm:"unique;not null" json:"username"`
    Password string `gorm:"not null" json:"-"`
    Email    string `gorm:"unique;not null" json:"email"`
    Roles    []Role `gorm:"many2many:user_roles" json:"roles"`
}

// dto/UserDto.go
package dto

type UserDto struct {
    Username string `json:"username" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
    RoleIds  []uint `json:"role_ids"`
}

type LoginDto struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required"`
}

// services/UserService.go
package services

import (
    "errors"
    "github.com/lucapierini/project-go-task_manager/config"
    "github.com/lucapierini/project-go-task_manager/dto"
    "github.com/lucapierini/project-go-task_manager/models"
    "github.com/lucapierini/project-go-task_manager/utils"
    "golang.org/x/crypto/bcrypt"
)

func RegisterUser(userDto dto.UserDto) (*models.User, error) {
    // Check if email already exists
    var existingUser models.User
    if result := config.DB.Where("email = ?", userDto.Email).First(&existingUser); result.Error == nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }

    // Create user
    user := models.User{
        Username: userDto.Username,
        Email:    userDto.Email,
        Password: string(hashedPassword),
    }

    // Add roles if specified
    if len(userDto.RoleIds) > 0 {
        var roles []models.Role
        if err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {
            return nil, err
        }
        user.Roles = roles
    }

    if err := config.DB.Create(&user).Error; err != nil {
        return nil, err
    }

    return &user, nil
}

func LoginUser(loginDto dto.LoginDto) (string, error) {
    var user models.User
    if err := config.DB.Where("email = ?", loginDto.Email).First(&user).Error; err != nil {
        return "", errors.New("invalid credentials")
    }

    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginDto.Password)); err != nil {
        return "", errors.New("invalid credentials")
    }

    token, err := utils.GenerateToken(user)
    if err != nil {
        return "", err
    }

    return token, nil
}

func GetUser(id uint) (*models.User, error) {
    var user models.User
    if err := config.DB.Preload("Roles").First(&user, id).Error; err != nil {
        return nil, err
    }
    return &user, nil
}

func ListUsers() ([]models.User, error) {
    var users []models.User
    if err := config.DB.Preload("Roles").Find(&users).Error; err != nil {
        return nil, err
    }
    return users, nil
}

func UpdateUser(id uint, userDto dto.UserDto) (*models.User, error) {
    user, err := GetUser(id)
    if err != nil {
        return nil, err
    }

    user.Username = userDto.Username
    user.Email = userDto.Email

    if userDto.Password != "" {
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)
        if err != nil {
            return nil, err
        }
        user.Password = string(hashedPassword)
    }

    // Update roles if specified
    if len(userDto.RoleIds) > 0 {
        var roles []models.Role
        if err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {
            return nil, err
        }
        user.Roles = roles
    }

    if err := config.DB.Save(user).Error; err != nil {
        return nil, err
    }

    return user, nil
}

func DeleteUser(id uint) error {
    if err := config.DB.Delete(&models.User{}, id).Error; err != nil {
        return err
    }
    return nil
}

// handlers/UserHandler.go
package handlers

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "github.com/lucapierini/project-go-task_manager/dto"
    "github.com/lucapierini/project-go-task_manager/services"
    "strconv"
)

type UserHandler struct{}

func NewUserHandler() *UserHandler {
    return &UserHandler{}
}

func (h *UserHandler) Register(c *gin.Context) {
    var userDto dto.UserDto
    if err := c.ShouldBindJSON(&userDto); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    user, err := services.RegisterUser(userDto)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusCreated, user)
}

func (h *UserHandler) Login(c *gin.Context) {
    var loginDto dto.LoginDto
    if err := c.ShouldBindJSON(&loginDto); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    token, err := services.LoginUser(loginDto)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
        return
    }

    // Set token as cookie
    c.SetCookie("Authorization", token, 3600*24, "", "", false, true)
    c.JSON(http.StatusOK, gin.H{"message": "successfully logged in"})
}

func (h *UserHandler) GetUser(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
        return
    }

    user, err := services.GetUser(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
        return
    }

    c.JSON(http.StatusOK, user)
}

func (h *UserHandler) ListUsers(c *gin.Context) {
    users, err := services.ListUsers()
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "error fetching users"})
        return
    }

    c.JSON(http.StatusOK, users)
}

func (h *UserHandler) UpdateUser(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
        return
    }

    var userDto dto.UserDto
    if err := c.ShouldBindJSON(&userDto); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    user, err := services.UpdateUser(uint(id), userDto)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, user)
}

func (h *UserHandler) DeleteUser(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
        return
    }

    if err := services.DeleteUser(uint(id)); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "error deleting user"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "user deleted successfully"})
}

// main.go - AÃ±adir a las rutas existentes
func loadRoutes() {
    userHandler := handlers.NewUserHandler()

    // Public routes
    router.POST("/register", userHandler.Register)
    router.POST("/login", userHandler.Login)

    // Protected routes
    auth := router.Group("/")
    auth.Use(middlewares.CheckToken)
    {
        auth.GET("/users", userHandler.ListUsers)
        auth.GET("/users/:id", userHandler.GetUser)
        auth.PUT("/users/:id", userHandler.UpdateUser)
        auth.DELETE("/users/:id", userHandler.DeleteUser)
    }
}





















// models/user.go
package models

import (
    "gorm.io/gorm"
)

type Role struct {
    gorm.Model
    Name        string `gorm:"unique;not null" json:"name"`
    Users       []User `gorm:"many2many:user_roles;" json:"users,omitempty"`
}

type User struct {
    gorm.Model
    Username    string `gorm:"unique;not null" json:"username"`
    Password    string `gorm:"not null" json:"-"`
    Email       string `gorm:"unique;not null" json:"email"`
    Roles       []Role `gorm:"many2many:user_roles;" json:"roles"`
}

// config/database.go
package config

import (
    "log"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "your-project/models"
)

func SetupDB() *gorm.DB {
    dsn := "host=localhost user=postgres password=postgres dbname=userdb port=5432 sslmode=disable"
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    // Auto Migrate
    db.AutoMigrate(&models.User{}, &models.Role{})
    return db
}

// utils/jwt.go
package utils

import (
    "time"
    "github.com/golang-jwt/jwt"
)

var jwtKey = []byte("your-secret-key")

func GenerateToken(userId uint) (string, error) {
    claims := jwt.MapClaims{
        "user_id": userId,
        "exp":     time.Now().Add(24 * time.Hour).Unix(),
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtKey)
}

func ValidateToken(tokenString string) (uint, error) {
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        return jwtKey, nil
    })

    if err != nil {
        return 0, err
    }

    if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
        userId := uint(claims["user_id"].(float64))
        return userId, nil
    }

    return 0, err
}

// middleware/auth.go
package middleware

import (
    "net/http"
    "strings"
    "your-project/utils"
    "github.com/gin-gonic/gin"
)

func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
            c.Abort()
            return
        }

        bearerToken := strings.Split(authHeader, " ")
        if len(bearerToken) != 2 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token format"})
            c.Abort()
            return
        }

        userId, err := utils.ValidateToken(bearerToken[1])
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }

        c.Set("userId", userId)
        c.Next()
    }
}

// handlers/user.go
package handlers

import (
    "net/http"
    "your-project/models"
    "your-project/utils"
    "golang.org/x/crypto/bcrypt"
    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
)

type UserHandler struct {
    db *gorm.DB
}

func NewUserHandler(db *gorm.DB) *UserHandler {
    return &UserHandler{db: db}
}

func (h *UserHandler) Register(c *gin.Context) {
    var user models.User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Error hashing password"})
        return
    }
    user.Password = string(hashedPassword)

    // Create user
    if err := h.db.Create(&user).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Error creating user"})
        return
    }

    c.JSON(http.StatusCreated, gin.H{"message": "User created successfully"})
}

func (h *UserHandler) Login(c *gin.Context) {
    var loginUser struct {
        Username string `json:"username"`
        Password string `json:"password"`
    }

    if err := c.ShouldBindJSON(&loginUser); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    var user models.User
    if err := h.db.Where("username = ?", loginUser.Username).First(&user).Error; err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
        return
    }

    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginUser.Password)); err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
        return
    }

    token, err := utils.GenerateToken(user.ID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Error generating token"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"token": token})
}

func (h *UserHandler) GetUsers(c *gin.Context) {
    var users []models.User
    if err := h.db.Preload("Roles").Find(&users).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Error fetching users"})
        return
    }

    c.JSON(http.StatusOK, users)
}

func (h *UserHandler) UpdateUser(c *gin.Context) {
    id := c.Param("id")
    var updateUser models.User

    if err := c.ShouldBindJSON(&updateUser); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    var user models.User
    if err := h.db.First(&user, id).Error; err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
        return
    }

    // Update user fields
    user.Username = updateUser.Username
    user.Email = updateUser.Email

    if err := h.db.Save(&user).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Error updating user"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "User updated successfully"})
}

func (h *UserHandler) DeleteUser(c *gin.Context) {
    id := c.Param("id")

    if err := h.db.Delete(&models.User{}, id).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Error deleting user"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})
}

// main.go
package main

import (
    "your-project/config"
    "your-project/handlers"
    "your-project/middleware"
    "github.com/gin-gonic/gin"
)

func main() {
    db := config.SetupDB()
    userHandler := handlers.NewUserHandler(db)

    r := gin.Default()

    // Public routes
    r.POST("/register", userHandler.Register)
    r.POST("/login", userHandler.Login)

    // Protected routes
    auth := r.Group("/")
    auth.Use(middleware.AuthMiddleware())
    {
        auth.GET("/users", userHandler.GetUsers)
        auth.PUT("/users/:id", userHandler.UpdateUser)
        auth.DELETE("/users/:id", userHandler.DeleteUser)
    }

    r.Run(":8080")
}