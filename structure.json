{
  "api": {
    "handlers": {
      "UserHandler.go": "package handlers\r\n\r\nimport (\r\n\r\n\t\"github.com/gin-gonic/gin\"\r\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\r\n\t\"github.com/lucapierini/project-go-task_manager/services\"\r\n)\r\n\r\ntype UserHandler struct {\r\n\tuserService services.UserInterface\r\n}\r\n\r\nfunc NewUserHandler(userService services.UserInterface) *UserHandler{\r\n\treturn &UserHandler{\r\n\t\tuserService : userService,\r\n\t}\r\n}\r\n\r\nfunc (h *UserHandler) Register(c *gin.Context){\r\n\tvar userDto dto.UserDto\r\n\r\n\tif c.Bind(&userDto) != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tuser, err := h.userService.RegisterUser(userDto)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, user)\r\n}"
    },
    "services": {
      "UserService.go": "package services\r\n\r\nimport (\r\n\t\"errors\"\r\n\r\n\t\"github.com/lucapierini/project-go-task_manager/config\"\r\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\r\n\t\"github.com/lucapierini/project-go-task_manager/models\"\r\n\t\"github.com/lucapierini/project-go-task_manager/utils\"\r\n\t\"golang.org/x/crypto/bcrypt\"\r\n)\r\n\r\ntype UserInterface interface {\r\n\tRegisterUser(userDto dto.UserDto) (*models.User, error)\r\n\tLoginUser(userDto dto.UserDto) (*models.User, error)\r\n\tGetUserById(id uint) (*models.User, error)\r\n\tGetUserByEmail(email string) (*models.User, error)\r\n\tListUsers() ([]models.User, error)\r\n\tUpdateUser(id uint, userDto dto.UserDto) (*models.User, error)\r\n\tDeleteUser(id uint) error\r\n}\r\n\r\nfunc RegisterUser(userDto dto.UserDto) (*models.User, error) {\r\n\t// Check if email already exists\r\n\tvar existingUser models.User\r\n\tif result := config.DB.Where(\"email = ?\", userDto.Email).First(&existingUser); result.Error == nil {\r\n\t\treturn nil, errors.New(\"email already registered\")\r\n\t}\r\n\r\n\t// Hash password\r\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\t// Create user\r\n\tuser := models.User{\r\n\t\tUsername: userDto.Username,\r\n\t\tEmail:    userDto.Email,\r\n\t\tPassword: string(hashedPassword),\r\n\t}\r\n\r\n\t// Add roles if specified\r\n\tif len(userDto.RoleIds) > 0 {\r\n\t\tvar roles []models.Role\r\n\t\tif err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Roles = roles\r\n\t}\r\n\r\n\tif err := config.DB.Create(&user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn &user, nil\r\n}\r\n\r\nfunc GetUserByEmail(email string) (*models.User, error) {\r\n\tvar user models.User\r\n\tif err := config.DB.Preload(\"Roles\").Where(\"email = ?\", email).First(&user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn &user, nil\r\n}\r\n\r\nfunc GetUserById(id uint) (*models.User, error) {\r\n    var user models.User\r\n    if err := config.DB.Preload(\"Roles\").Where(\"id = ?\", id).First(&user).Error; err != nil {\r\n        return nil, err\r\n    }\r\n    return &user, nil\r\n}\r\n\r\nfunc UpdateUser(id uint, userDto dto.UserDto) (*models.User, error) {\r\n\tuser, err := GetUserById(id)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tuser.Username = userDto.Username\r\n\tuser.Email = userDto.Email\r\n\r\n\tif userDto.Password != \"\" {\r\n\t\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Password = string(hashedPassword)\r\n\t}\r\n\r\n\t// Update roles if specified\r\n\tif len(userDto.RoleIds) > 0 {\r\n\t\tvar roles []models.Role\r\n\t\tif err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Roles = roles\r\n\t}\r\n\r\n\tif err := config.DB.Save(user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn user, nil\r\n}\r\n\r\nfunc DeleteUser(id uint) error {\r\n\tif err := config.DB.Delete(&models.User{}, id).Error; err != nil {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc ListUsers() ([]models.User, error) {\r\n\tvar users []models.User\r\n\tif err := config.DB.Preload(\"Roles\").Find(&users).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn users, nil\r\n}\r\n\r\nfunc LoginUser(loginDto dto.LoginDto) (string, error) {\r\n\tvar user models.User\r\n\tif err := config.DB.Where(\"email = ?\", loginDto.Email).First(&user).Error; err != nil {\r\n\t\treturn \"\", errors.New(\"invalid credentials\")\r\n\t}\r\n\r\n\tif err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginDto.Password)); err != nil {\r\n\t\treturn \"\", errors.New(\"invalid credentials\")\r\n\t}\r\n\r\n\ttoken, err := utils.GenerateToken(user)\r\n\tif err != nil {\r\n\t\treturn \"\", err\r\n\t}\r\n\r\n\treturn token, nil\r\n}\r\n"
    }
  }
}