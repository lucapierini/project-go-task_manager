{
  "api": {
    "config": {
      "connectDB.go": "package config\r\n\r\nimport (\r\n\t\"gorm.io/gorm\"\r\n\t\"gorm.io/driver/postgres\"\r\n\t\"os\"\r\n\t\"log\"\r\n\t\r\n)\r\n\r\nvar DB *gorm.DB\r\n\r\nfunc ConnectDB() {\r\n\tvar err error\r\n\tdsn := os.Getenv(\"DB_URL\")\r\n\tDB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})\r\n\r\n\tif err != nil {\r\n\t\tlog.Fatal(\"Failed to connect DB with error: \", err)\r\n\t} else {\r\n\t\tlog.Println(\"Connected to DB\")\r\n\t}\r\n}",
      "defaultRoles.go": "package config\r\n\r\n// import (\r\n// \t\"github.com/lucapierini/project-go-task_manager/config\"\r\n// \t\"github.com/lucapierini/project-go-task_manager/models\"\r\n// )\r\n\r\n// func CreateDefaultRoles(){\r\n// \t// Create default roles\r\n// \trole := models.Role{Name: \"Administrador\"}\r\n// \tif err := config.DB.Create(&role).Error; err != nil {\r\n// \t\treturn nil, err\r\n// \t}\r\n// \treturn &role, nil\r\n// }\r\n\r\n\r\n// func CreateRole(roleDto dto.RoleDto) (*models.Role, error){\r\n// \trole := models.Role{Name: roleDto.Name}\r\n// \tif err := config.DB.Create(&role).Error; err != nil {\r\n// \t\treturn nil, err\r\n// \t}\r\n// \treturn &role, nil\r\n// }",
      "loadEnvVariables.go": "package config\r\n\r\nimport (\r\n\t\"path/filepath\"\r\n\t\"log\"\r\n\t\"github.com/joho/godotenv\"\r\n)\r\n\r\nfunc LoadEnvVariables() {\r\n\t// Load environment variables\r\n\tenvPath := filepath.Join(\"..\", \".env\")\r\n\r\n\terr := godotenv.Load(envPath)\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Error loading .env file\")\r\n\t}\r\n}",
      "syncDB.go": "package config\r\n\r\nimport \"github.com/lucapierini/project-go-task_manager/models\"\r\n\r\nfunc SyncDB() {\r\n\t// DB.AutoMigrate(&models.Project{})\r\n\t// DB.AutoMigrate(&models.Task{})\r\n\tDB.AutoMigrate(&models.User{})\r\n\tDB.AutoMigrate(&models.Role{})\r\n}"
    },
    "dto": {
      "RoleDto.go": "package dto\r\n\r\ntype RoleDto struct {\r\n\tName string `json:\"name\" binding:\"required\"`\r\n}",
      "UserDto.go": "package dto\r\n\r\ntype UserDto struct {\r\n    Username string `json:\"username\" binding:\"required\"`\r\n    Email    string `json:\"email\" binding:\"required,email\"`\r\n    Password string `json:\"password\" binding:\"required,min=6\"`\r\n    RoleIds  []uint `json:\"role_ids\"`\r\n}"
    },
    "handlers": {
      "UserHandler.go": "package handlers\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"strconv\"\r\n\t\"time\"\r\n\r\n\t\"github.com/gin-gonic/gin\"\r\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\r\n\t\"github.com/lucapierini/project-go-task_manager/middlewares\"\r\n\t\"github.com/lucapierini/project-go-task_manager/services\"\r\n)\r\n\r\ntype UserHandler struct {\r\n\tuserService services.UserInterface\r\n}\r\n\r\nfunc NewUserHandler(userService services.UserInterface) *UserHandler{\r\n\treturn &UserHandler{\r\n\t\tuserService : userService,\r\n\t}\r\n}\r\n\r\nfunc (h *UserHandler) Register(c *gin.Context){\r\n\t// var userDto dto.UserDto\r\n\r\n\tvar userDtoRegister struct{\r\n\t\tUsername string `json:\"username\" binding:\"required\"`\r\n\t\tEmail    string `json:\"email\" binding:\"required,email\"`\r\n\t\tPassword string `json:\"password\" binding:\"required,min=6\"`\r\n\t}\r\n\r\n\tif c.Bind(&userDtoRegister) != nil {\r\n\t\t\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\", \"data\": userDtoRegister})\r\n\t\treturn\r\n\t}\r\n\r\n\tuser, err := h.userService.RegisterUser(dto.UserDto{Username: userDtoRegister.Username, Email: userDtoRegister.Email, Password: userDtoRegister.Password})\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, user)\r\n}\r\n\r\nfunc (h *UserHandler) Login(c *gin.Context){\r\n\tvar loginDto dto.LoginDto\r\n\r\n\tif err := c.ShouldBindJSON(&loginDto); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tfmt.Println(loginDto)\r\n\r\n\tuser, err := h.userService.LoginUser(loginDto)\r\n\tif err != nil {\r\n\t\tc.JSON(401, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tfmt.Println(\"generating token for: \" + user.Username)\r\n\t// token, err := utils.GenerateToken(user)\r\n\ttoken, err := middlewares.GenerateToken(user)\r\n\tif err != nil {\r\n\t\tc.JSON(401, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.SetCookie(\"auth_token\", token, int(time.Now().Add(1*time.Hour).Unix()), \"/\", \"\", false, true)\r\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Login successful\"})\r\n\t// Responder con el token\r\n\t// c.SetSameSite(http.SameSiteNoneMode)\r\n\t// c.SetCookie(\"Authorization\", token, 3600 * 24 * 30 ,\"\", \"\", false, true)\r\n\r\n\tc.JSON(200, gin.H{\"token\": token})\r\n}\r\n\r\nfunc (h *UserHandler) GetUser(c *gin.Context){\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid Id\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tuser, err := h.userService.GetUserById(uint(id))\r\n\tif err != nil {\r\n\t\tc.JSON(404, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, user)\r\n}\r\n\r\nfunc (h *UserHandler) GetUserByEmail(c *gin.Context) {\r\n\temail := c.Query(\"email\")\r\n\tif email == \"\" {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Email is required\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tuser, err := h.userService.GetUserByEmail(email)\r\n\tif err != nil {\r\n\t\tc.JSON(404, gin.H{\"error\": \"User not found\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, user)\r\n}\r\n\r\nfunc (h *UserHandler) ListUsers(c *gin.Context) {\r\n\tusers, err := h.userService.ListUsers()\r\n\tif err != nil {\r\n\t\tc.JSON(500, gin.H{\"error\": \"Failed to fetch users\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, users)\r\n}\r\n\r\nfunc (h *UserHandler) UpdateUser(c *gin.Context) {\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tvar userDto dto.UserDto\r\n\tif err := c.ShouldBindJSON(&userDto); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tuser, err := h.userService.UpdateUser(uint(id), userDto)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, user)\r\n}\r\n\r\nfunc (h *UserHandler) DeleteUser(c *gin.Context) {\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tif err := h.userService.DeleteUser(uint(id)); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, gin.H{\"message\": \"User deleted successfully\"})\r\n}"
    },
    "middlewares": {
      "Auth.go": "package middlewares\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"os\"\r\n\t\"strings\"\r\n\t\"time\"\r\n\r\n\t\"github.com/gin-gonic/gin\"\r\n\t\"github.com/golang-jwt/jwt\"\r\n\t\"github.com/lucapierini/project-go-task_manager/models\"\r\n)\r\n\r\nvar JWT_SECRET = []byte(os.Getenv(\"JWT_SECRET\"))\r\n\r\ntype Claims struct {\r\n\tUserID uint\r\n\tRoles  []string\r\n\tjwt.StandardClaims\r\n}\r\n\r\n// GenerateToken genera un JWT con los claims del usuario\r\nfunc GenerateToken(user *models.User) (string, error) {\r\n\tvar roleNames []string\r\n\tfor _, role := range user.Roles {\r\n\t\troleNames = append(roleNames, role.Name)\r\n\t}\r\n\r\n\tclaims := Claims{\r\n\t\tUserID: user.ID,\r\n\t\tRoles:  roleNames,\r\n\t\tStandardClaims: jwt.StandardClaims{\r\n\t\t\tExpiresAt: time.Now().Add(24 * time.Hour).Unix(),\r\n\t\t\tIssuedAt:  time.Now().Unix(),\r\n\t\t},\r\n\t}\r\n\r\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n\ttokenString, err := token.SignedString(JWT_SECRET)\r\n\tif err != nil {\r\n\t\treturn \"\", fmt.Errorf(\"error al generar token: %v\", err)\r\n\t}\r\n\r\n\treturn tokenString, nil\r\n}\r\n\r\n// ValidateToken valida el JWT y retorna los claims si es válido\r\nfunc ValidateToken(tokenString string) (*Claims, error) {\r\n\ttoken, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {\r\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\r\n\t\t\treturn nil, fmt.Errorf(\"método de firma inesperado: %v\", token.Header[\"alg\"])\r\n\t\t}\r\n\t\treturn JWT_SECRET, nil\r\n\t})\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tif claims, ok := token.Claims.(*Claims); ok && token.Valid {\r\n\t\treturn claims, nil\r\n\t}\r\n\r\n\treturn nil, errors.New(\"token inválido\")\r\n}\r\n\r\n// AuthMiddleware middleware para validar el JWT\r\nfunc AuthMiddleware(requiredRoles ...string) gin.HandlerFunc {\r\n\treturn func(c *gin.Context) {\r\n\t\tauthHeader := c.GetHeader(\"Authorization\")\r\n\t\tif authHeader == \"\" {\r\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"token no proporcionado\"})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\ttokenString := strings.Replace(authHeader, \"Bearer \", \"\", 1)\r\n\t\tclaims, err := ValidateToken(tokenString)\r\n\t\tif err != nil {\r\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"token inválido\"})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Si se requieren roles específicos, validarlos\r\n\t\tif len(requiredRoles) > 0 {\r\n\t\t\thasRequiredRole := false\r\n\t\t\tfor _, requiredRole := range requiredRoles {\r\n\t\t\t\tfor _, userRole := range claims.Roles {\r\n\t\t\t\t\tif requiredRole == userRole {\r\n\t\t\t\t\t\thasRequiredRole = true\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif hasRequiredRole {\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif !hasRequiredRole {\r\n\t\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"no tiene los permisos necesarios\"})\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Almacenar los claims en el contexto para uso posterior\r\n\t\tc.Set(\"userID\", claims.UserID)\r\n\t\tc.Set(\"userRoles\", claims.Roles)\r\n\t\tc.Next()\r\n\t}\r\n}"
    },
    "models": {
      "Role.go": "package models\r\n\r\nimport \"gorm.io/gorm\"\r\n\r\ntype Role struct {\r\n\tgorm.Model\r\n\tName string `gorm:\"unique;not null\" json:\"name\"`\r\n\tUsers []User `gorm:\"many2many:user_roles\" json:\"users,omitempty\"`\r\n}\r\n\r\n",
      "User.go": "package models\r\n\r\nimport (\r\n\t\"gorm.io/gorm\"\r\n)\r\n\r\ntype User struct {\r\n\tgorm.Model\r\n\tUsername string `gorm:\"unique;not null\"`\r\n\tPassword string `gorm:\"not null\"`\r\n\tEmail string `gorm:\"unique;not null\"`\r\n\tRoles []Role `gorm:\"many2many:user_roles\"`\r\n}"
    },
    "services": {
      "UserService.go": "package services\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\r\n\t\"github.com/lucapierini/project-go-task_manager/config\"\r\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\r\n\t\"github.com/lucapierini/project-go-task_manager/models\"\r\n\t// \"github.com/lucapierini/project-go-task_manager/utils\"\r\n\t\"golang.org/x/crypto/bcrypt\"\r\n)\r\n\r\ntype UserInterface interface {\r\n    RegisterUser(userDto dto.UserDto) (*models.User, error)\r\n    LoginUser(loginDto dto.LoginDto) (*models.User, error)\r\n    GetUserById(id uint) (*models.User, error)\r\n    GetUserByEmail(email string) (*models.User, error)\r\n    ListUsers() ([]models.User, error)\r\n    UpdateUser(id uint, userDto dto.UserDto) (*models.User, error)\r\n    DeleteUser(id uint) error // Este método debe estar presente\r\n}\r\n\r\ntype UserService struct{}\r\n\r\nfunc NewUserService() *UserService {\r\n\treturn &UserService{}\r\n}\r\n\r\nvar (\r\n\tErrEmailAlreadyRegistered = errors.New(\"email already registered\")\r\n\tErrInvalidData            = errors.New(\"invalid data provided\")\r\n)\r\n\r\nfunc (s *UserService) RegisterUser(userDto dto.UserDto) (*models.User, error) {\r\n\t// Check if email already exists\r\n\tvar existingUser models.User\r\n\tif result := config.DB.Where(\"email = ?\", userDto.Email).First(&existingUser); result.Error == nil {\r\n\t\treturn nil, errors.New(\"email already registered\")\r\n\t}\r\n\r\n\t// Hash password\r\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\t// Create user\r\n\tuser := models.User{\r\n\t\tUsername: userDto.Username,\r\n\t\tEmail:    userDto.Email,\r\n\t\tPassword: string(hashedPassword),\r\n\t}\r\n\r\n\t// Add roles if specified\r\n\tif len(userDto.RoleIds) > 0 {\r\n\t\tvar roles []models.Role\r\n\t\tif err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Roles = roles\r\n\t} else {\r\n\t\t// If no roles are specified, assign default role\r\n\t\tvar defaultRole models.Role\r\n\t\tif err := config.DB.First(&defaultRole, \"name = ?\", \"Usuario\").Error; err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Roles = []models.Role{defaultRole}\r\n\t}\r\n\r\n\tif err := config.DB.Create(&user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn &user, nil\r\n}\r\n\r\n\r\nfunc (s *UserService) LoginUser(loginDto dto.LoginDto) (*models.User, error) {\r\n\tvar user models.User\r\n\tif err := config.DB.Preload(\"Roles\").Where(\"email = ?\", loginDto.Email).First(&user).Error; err != nil {\r\n\t\tfmt.Println(\"invalid credentials\")\r\n\t\treturn nil, errors.New(\"invalid credentials\")\r\n\t}\r\n\r\n\tif err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginDto.Password)); err != nil {\r\n\t\tfmt.Println(\"invalid password\")\r\n\t\treturn nil, errors.New(\"invalid credentials\")\r\n\t}\r\n\r\n\treturn &user, nil\r\n}\r\n\r\n\r\nfunc (s *UserService) GetUserByEmail(email string) (*models.User, error) {\r\n\tvar user models.User\r\n\tif err := config.DB.Preload(\"Roles\").Where(\"email = ?\", email).First(&user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn &user, nil\r\n}\r\n\r\nfunc (s *UserService) GetUserById(id uint) (*models.User, error) {\r\n    var user models.User\r\n    if err := config.DB.Preload(\"Roles\").Where(\"id = ?\", id).First(&user).Error; err != nil {\r\n        return nil, err\r\n    }\r\n    return &user, nil\r\n}\r\n\r\nfunc (s *UserService) UpdateUser(id uint, userDto dto.UserDto) (*models.User, error) {\r\n\tuser, err := s.GetUserById(id)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tuser.Username = userDto.Username\r\n\tuser.Email = userDto.Email\r\n\r\n\tif userDto.Password != \"\" {\r\n\t\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Password = string(hashedPassword)\r\n\t}\r\n\r\n\t// Update roles if specified\r\n\tif len(userDto.RoleIds) > 0 {\r\n\t\tvar roles []models.Role\r\n\t\tif err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Roles = roles\r\n\t}\r\n\r\n\tif err := config.DB.Save(user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn user, nil\r\n}\r\n\r\n\r\n\r\nfunc (s *UserService) ListUsers() ([]models.User, error) {\r\n\tvar users []models.User\r\n\tif err := config.DB.Preload(\"Roles\").Find(&users).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn users, nil\r\n}\r\n\r\nfunc (s *UserService) DeleteUser (id uint) error {\r\n    if err := config.DB.Delete(&models.User{}, id).Error; err != nil {\r\n        return err\r\n    }\r\n    return nil\r\n}"
    }
  }
}