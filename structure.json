{
  ".env": "PORT=9000\r\nJWT_SECRET=clave_secreta\r\n# URL para local\r\nDB_URL=\"host=localhost user=userTest password=task123456 dbname=go-task_manager port=5432 sslmode=disable\"\r\n\r\n# URL para Docker\r\n# DB_URL=\"host=postgres user=userTest password=task123456 dbname=go-task_manager port=5432 sslmode=disable\"",
  "api": {
    "dto": {
      "LoginDto.go": "package dto\r\n\r\ntype LoginDto struct {\r\n    Email    string `json:\"email\" binding:\"required,email\"`\r\n    Password string `json:\"password\" binding:\"required\"`\r\n}",
      "RoleDto.go": "package dto\r\n\r\ntype RoleDto struct {\r\n\tName string `json:\"name\" binding:\"required\"`\r\n}",
      "UserDto.go": "package dto\r\n\r\ntype UserDto struct {\r\n    Username string `json:\"username\" binding:\"required\"`\r\n    Email    string `json:\"email\" binding:\"required,email\"`\r\n    Password string `json:\"password\" binding:\"required,min=6\"`\r\n    RoleIds  []uint `json:\"role_ids\"`\r\n}"
    },
    "handlers": {
      "RoleHandler.go": "package handlers\r\n\r\nimport (\r\n\t\"strconv\"\r\n\r\n\t\"github.com/gin-gonic/gin\"\r\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\r\n\t\"github.com/lucapierini/project-go-task_manager/services\"\r\n)\r\n\r\ntype RoleHandler struct {\r\n\troleService services.RoleInterface\r\n}\r\n\r\nfunc NewRoleHandler(roleService services.RoleInterface) *RoleHandler {\r\n    return &RoleHandler{\r\n        roleService: roleService,\r\n    }\r\n}\r\n\r\nfunc (h *RoleHandler) CreateRole(c *gin.Context) {\r\n\tvar roleDto dto.RoleDto\r\n\tif err := c.ShouldBindJSON(&roleDto); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\r\n\t\treturn\r\n\t}\r\n\r\n\trole, err := h.roleService.CreateRole(roleDto)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(201, role)\r\n}\r\n\r\nfunc (h *RoleHandler) GetRole(c *gin.Context) {\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\r\n\t\treturn\r\n\t}\r\n\r\n\trole, err := h.roleService.GetRoleById(uint(id))\r\n\tif err != nil {\r\n\t\tc.JSON(404, gin.H{\"error\": \"Role not found\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, role)\r\n}\r\n\r\nfunc (h *RoleHandler) UpdateRole(c *gin.Context) {\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tvar roleDto dto.RoleDto\r\n\tif err := c.ShouldBindJSON(&roleDto); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\r\n\t\treturn\r\n\t}\r\n\r\n\trole, err := h.roleService.UpdateRole(uint(id), roleDto)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, role)\r\n}\r\n\r\nfunc (h *RoleHandler) DeleteRole(c *gin.Context) {\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tif err := h.roleService.DeleteRole(uint(id)); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, gin.H{\"message\": \"Role deleted successfully\"})\r\n}\r\n\r\nfunc (h *RoleHandler) ListRoles(c *gin.Context) {\r\n\troles, err := h.roleService.ListRoles()\r\n\tif err != nil {\r\n\t\tc.JSON(500, gin.H{\"error\": \"Failed to fetch roles\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, roles)\r\n}",
      "UserHandler.go": "package handlers\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"strconv\"\r\n\t\"time\"\r\n\r\n\t\"github.com/gin-gonic/gin\"\r\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\r\n\t\"github.com/lucapierini/project-go-task_manager/middlewares\"\r\n\t\"github.com/lucapierini/project-go-task_manager/services\"\r\n)\r\n\r\ntype UserHandler struct {\r\n\tuserService services.UserInterface\r\n}\r\n\r\nfunc NewUserHandler(userService services.UserInterface) *UserHandler{\r\n\treturn &UserHandler{\r\n\t\tuserService : userService,\r\n\t}\r\n}\r\n\r\nfunc (h *UserHandler) Register(c *gin.Context) {\r\n    var userDto dto.UserDto\r\n    if err := c.ShouldBindJSON(&userDto); err != nil {\r\n        c.JSON(http.StatusBadRequest, gin.H{\r\n            \"error\": \"Invalid request data\",\r\n            \"details\": err.Error(),\r\n        })\r\n        return\r\n    }\r\n\r\n    user, err := h.userService.RegisterUser(userDto)\r\n    if err != nil {\r\n        statusCode := http.StatusInternalServerError\r\n        if err == services.ErrEmailAlreadyRegistered {\r\n            statusCode = http.StatusConflict\r\n        } else if err == services.ErrInvalidData {\r\n            statusCode = http.StatusBadRequest\r\n        }\r\n\r\n        c.JSON(statusCode, gin.H{\r\n            \"error\": err.Error(),\r\n        })\r\n        return\r\n    }\r\n\r\n    c.JSON(http.StatusCreated, user)\r\n}\r\n\r\nfunc (h *UserHandler) Login(c *gin.Context){\r\n\tvar loginDto dto.LoginDto\r\n\r\n\tif err := c.ShouldBindJSON(&loginDto); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tfmt.Println(loginDto)\r\n\r\n\tuser, err := h.userService.LoginUser(loginDto)\r\n\tif err != nil {\r\n\t\tc.JSON(401, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tfmt.Println(\"generating token for: \" + user.Username)\r\n\t// token, err := utils.GenerateToken(user)\r\n\ttoken, err := middlewares.GenerateToken(user)\r\n\tif err != nil {\r\n\t\tc.JSON(401, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.SetCookie(\"auth_token\", token, int(time.Now().Add(1*time.Hour).Unix()), \"/\", \"\", false, true)\r\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Login successful\"})\r\n\t// Responder con el token\r\n\t// c.SetSameSite(http.SameSiteNoneMode)\r\n\t// c.SetCookie(\"Authorization\", token, 3600 * 24 * 30 ,\"\", \"\", false, true)\r\n\r\n\tc.JSON(200, gin.H{\"token\": token})\r\n}\r\n\r\nfunc (h *UserHandler) GetUser(c *gin.Context){\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid Id\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tuser, err := h.userService.GetUserById(uint(id))\r\n\tif err != nil {\r\n\t\tc.JSON(404, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, user)\r\n}\r\n\r\nfunc (h *UserHandler) GetUserByEmail(c *gin.Context) {\r\n\temail := c.Query(\"email\")\r\n\tif email == \"\" {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Email is required\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tuser, err := h.userService.GetUserByEmail(email)\r\n\tif err != nil {\r\n\t\tc.JSON(404, gin.H{\"error\": \"User not found\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, user)\r\n}\r\n\r\nfunc (h *UserHandler) ListUsers(c *gin.Context) {\r\n\tusers, err := h.userService.ListUsers()\r\n\tif err != nil {\r\n\t\tc.JSON(500, gin.H{\"error\": \"Failed to fetch users\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, users)\r\n}\r\n\r\nfunc (h *UserHandler) UpdateUser(c *gin.Context) {\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tvar userDto dto.UserDto\r\n\tif err := c.ShouldBindJSON(&userDto); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tuser, err := h.userService.UpdateUser(uint(id), userDto)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, user)\r\n}\r\n\r\nfunc (h *UserHandler) DeleteUser(c *gin.Context) {\r\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\r\n\tif err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tif err := h.userService.DeleteUser(uint(id)); err != nil {\r\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(200, gin.H{\"message\": \"User deleted successfully\"})\r\n}"
    },
    "middlewares": {
      "Auth.go": "package middlewares\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"os\"\r\n\t\"strings\"\r\n\t\"time\"\r\n\r\n\t\"github.com/gin-gonic/gin\"\r\n\t\"github.com/golang-jwt/jwt\"\r\n\t\"github.com/lucapierini/project-go-task_manager/models\"\r\n)\r\n\r\nvar JWT_SECRET = []byte(os.Getenv(\"JWT_SECRET\"))\r\n\r\ntype Claims struct {\r\n\tUserID uint\r\n\tRoles  []string\r\n\tjwt.StandardClaims\r\n}\r\n\r\n// GenerateToken genera un JWT con los claims del usuario\r\nfunc GenerateToken(user *models.User) (string, error) {\r\n\tvar roleNames []string\r\n\tfor _, role := range user.Roles {\r\n\t\troleNames = append(roleNames, role.Name)\r\n\t}\r\n\r\n\tclaims := Claims{\r\n\t\tUserID: user.ID,\r\n\t\tRoles:  roleNames,\r\n\t\tStandardClaims: jwt.StandardClaims{\r\n\t\t\tExpiresAt: time.Now().Add(24 * time.Hour).Unix(),\r\n\t\t\tIssuedAt:  time.Now().Unix(),\r\n\t\t},\r\n\t}\r\n\r\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n\ttokenString, err := token.SignedString(JWT_SECRET)\r\n\tif err != nil {\r\n\t\treturn \"\", fmt.Errorf(\"error al generar token: %v\", err)\r\n\t}\r\n\r\n\treturn tokenString, nil\r\n}\r\n\r\n// ValidateToken valida el JWT y retorna los claims si es válido\r\nfunc ValidateToken(tokenString string) (*Claims, error) {\r\n\ttoken, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {\r\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\r\n\t\t\treturn nil, fmt.Errorf(\"método de firma inesperado: %v\", token.Header[\"alg\"])\r\n\t\t}\r\n\t\treturn JWT_SECRET, nil\r\n\t})\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tif claims, ok := token.Claims.(*Claims); ok && token.Valid {\r\n\t\treturn claims, nil\r\n\t}\r\n\r\n\treturn nil, errors.New(\"token inválido\")\r\n}\r\n\r\n// AuthMiddleware middleware para validar el JWT\r\nfunc AuthMiddleware(requiredRoles ...string) gin.HandlerFunc {\r\n\treturn func(c *gin.Context) {\r\n\t\tauthHeader := c.GetHeader(\"Authorization\")\r\n\t\tif authHeader == \"\" {\r\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"token no proporcionado\"})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\ttokenString := strings.Replace(authHeader, \"Bearer \", \"\", 1)\r\n\t\tclaims, err := ValidateToken(tokenString)\r\n\t\tif err != nil {\r\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"token inválido\"})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Si se requieren roles específicos, validarlos\r\n\t\tif len(requiredRoles) > 0 {\r\n\t\t\thasRequiredRole := false\r\n\t\t\tfor _, requiredRole := range requiredRoles {\r\n\t\t\t\tfor _, userRole := range claims.Roles {\r\n\t\t\t\t\tif requiredRole == userRole {\r\n\t\t\t\t\t\thasRequiredRole = true\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif hasRequiredRole {\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif !hasRequiredRole {\r\n\t\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"no tiene los permisos necesarios\"})\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Almacenar los claims en el contexto para uso posterior\r\n\t\tc.Set(\"userID\", claims.UserID)\r\n\t\tc.Set(\"userRoles\", claims.Roles)\r\n\t\tc.Next()\r\n\t}\r\n}",
      "CorsMiddleware.go": "package middlewares\r\n\r\nimport \"github.com/gin-gonic/gin\"\r\n\r\nfunc CORSMiddleware() gin.HandlerFunc {\r\n\treturn func(c *gin.Context) {\r\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\r\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\r\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"*\")\r\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS, GET, PUT\")\r\n\r\n\t\tif c.Request.Method == \"OPTIONS\" {\r\n\t\t\tc.AbortWithStatus(204)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tc.Next()\r\n\t}\r\n}\r\n"
    },
    "models": {
      "Role.go": "package models\r\n\r\nimport \"gorm.io/gorm\"\r\n\r\ntype Role struct {\r\n\tgorm.Model\r\n\tName string `gorm:\"unique;not null\" json:\"name\"`\r\n\tUsers []User `gorm:\"many2many:user_roles\" json:\"users,omitempty\"`\r\n}\r\n\r\n",
      "User.go": "package models\r\n\r\nimport (\r\n\t\"gorm.io/gorm\"\r\n)\r\n\r\ntype User struct {\r\n\tgorm.Model\r\n\tUsername string `gorm:\"unique;not null\"`\r\n\tPassword string `gorm:\"not null\"`\r\n\tEmail string `gorm:\"unique;not null\"`\r\n\tRoles []Role `gorm:\"many2many:user_roles\"`\r\n}"
    },
    "services": {
      "RoleService.go": "package services\r\n\r\nimport (\r\n\t\"github.com/lucapierini/project-go-task_manager/config\"\r\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\r\n\t\"github.com/lucapierini/project-go-task_manager/models\"\r\n)\r\n\r\ntype RoleInterface interface {\r\n\tCreateRole(roleDto dto.RoleDto) (*models.Role, error)\r\n\tGetRoleById(id uint) (*models.Role, error)\r\n\tUpdateRole(id uint, roleDto dto.RoleDto) (*models.Role, error)\r\n\tDeleteRole(id uint) error\r\n\tListRoles() ([]models.Role, error)\r\n\t}\r\n\r\ntype RoleService struct{}\r\n\r\nfunc NewRoleService() *RoleService {\r\n\treturn &RoleService{}\r\n}\r\n\r\nfunc (s *RoleService) CreateRole(roleDto dto.RoleDto) (*models.Role, error){\r\n\trole := models.Role{Name: roleDto.Name}\r\n\tif err := config.DB.Create(&role).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn &role, nil\r\n}\r\n\r\nfunc (s *RoleService) GetRoleById(id uint) (*models.Role, error){\r\n\tvar role models.Role\r\n\tif err := config.DB.First(&role, id).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn &role, nil\r\n}\r\n\r\nfunc (s *RoleService) UpdateRole(id uint, roleDto dto.RoleDto) (*models.Role, error){\r\n\trole, err := s.GetRoleById(id)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\trole.Name = roleDto.Name\r\n\tif err := config.DB.Save(&role).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn role, nil\r\n}\r\n\r\nfunc (s *RoleService) DeleteRole(id uint) error {\r\n\tif err := config.DB.Delete(&models.Role{},id).Error; err != nil {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (s *RoleService) ListRoles()([]models.Role, error){\r\n\tvar roles []models.Role\r\n\tif err := config.DB.Find(&roles).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn roles, nil\r\n}",
      "UserService.go": "package services\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\r\n\t\"github.com/lucapierini/project-go-task_manager/config\"\r\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\r\n\t\"github.com/lucapierini/project-go-task_manager/models\"\r\n\t// \"github.com/lucapierini/project-go-task_manager/utils\"\r\n\t\"golang.org/x/crypto/bcrypt\"\r\n)\r\n\r\ntype UserInterface interface {\r\n    RegisterUser(userDto dto.UserDto) (*models.User, error)\r\n    LoginUser(loginDto dto.LoginDto) (*models.User, error)\r\n    GetUserById(id uint) (*models.User, error)\r\n    GetUserByEmail(email string) (*models.User, error)\r\n    ListUsers() ([]models.User, error)\r\n    UpdateUser(id uint, userDto dto.UserDto) (*models.User, error)\r\n    DeleteUser(id uint) error // Este método debe estar presente\r\n}\r\n\r\ntype UserService struct{}\r\n\r\nfunc NewUserService() *UserService {\r\n\treturn &UserService{}\r\n}\r\n\r\nvar (\r\n\tErrEmailAlreadyRegistered = errors.New(\"email already registered\")\r\n\tErrInvalidData            = errors.New(\"invalid data provided\")\r\n)\r\n\r\nfunc (s *UserService) RegisterUser(userDto dto.UserDto) (*models.User, error) {\r\n\t// Check if email already exists\r\n\tvar existingUser models.User\r\n\tif result := config.DB.Where(\"email = ?\", userDto.Email).First(&existingUser); result.Error == nil {\r\n\t\treturn nil, errors.New(\"email already registered\")\r\n\t}\r\n\r\n\t// Hash password\r\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\t// Create user\r\n\tuser := models.User{\r\n\t\tUsername: userDto.Username,\r\n\t\tEmail:    userDto.Email,\r\n\t\tPassword: string(hashedPassword),\r\n\t}\r\n\r\n\t// Add roles if specified\r\n\tif len(userDto.RoleIds) > 0 {\r\n\t\tvar roles []models.Role\r\n\t\tif err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Roles = roles\r\n\t} else {\r\n\t\t// If no roles are specified, assign default role\r\n\t\tvar defaultRole models.Role\r\n\t\tif err := config.DB.First(&defaultRole, \"name = ?\", \"Usuario\").Error; err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Roles = []models.Role{defaultRole}\r\n\t}\r\n\r\n\tif err := config.DB.Create(&user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn &user, nil\r\n}\r\n\r\n\r\nfunc (s *UserService) LoginUser(loginDto dto.LoginDto) (*models.User, error) {\r\n\tvar user models.User\r\n\tif err := config.DB.Preload(\"Roles\").Where(\"email = ?\", loginDto.Email).First(&user).Error; err != nil {\r\n\t\tfmt.Println(\"invalid credentials\")\r\n\t\treturn nil, errors.New(\"invalid credentials\")\r\n\t}\r\n\r\n\tif err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginDto.Password)); err != nil {\r\n\t\tfmt.Println(\"invalid password\")\r\n\t\treturn nil, errors.New(\"invalid credentials\")\r\n\t}\r\n\r\n\treturn &user, nil\r\n}\r\n\r\n\r\nfunc (s *UserService) GetUserByEmail(email string) (*models.User, error) {\r\n\tvar user models.User\r\n\tif err := config.DB.Preload(\"Roles\").Where(\"email = ?\", email).First(&user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn &user, nil\r\n}\r\n\r\nfunc (s *UserService) GetUserById(id uint) (*models.User, error) {\r\n    var user models.User\r\n    if err := config.DB.Preload(\"Roles\").Where(\"id = ?\", id).First(&user).Error; err != nil {\r\n        return nil, err\r\n    }\r\n    return &user, nil\r\n}\r\n\r\nfunc (s *UserService) UpdateUser(id uint, userDto dto.UserDto) (*models.User, error) {\r\n\tuser, err := s.GetUserById(id)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tuser.Username = userDto.Username\r\n\tuser.Email = userDto.Email\r\n\r\n\tif userDto.Password != \"\" {\r\n\t\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Password = string(hashedPassword)\r\n\t}\r\n\r\n\t// Update roles if specified\r\n\tif len(userDto.RoleIds) > 0 {\r\n\t\tvar roles []models.Role\r\n\t\tif err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tuser.Roles = roles\r\n\t}\r\n\r\n\tif err := config.DB.Save(user).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn user, nil\r\n}\r\n\r\n\r\n\r\nfunc (s *UserService) ListUsers() ([]models.User, error) {\r\n\tvar users []models.User\r\n\tif err := config.DB.Preload(\"Roles\").Find(&users).Error; err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn users, nil\r\n}\r\n\r\nfunc (s *UserService) DeleteUser (id uint) error {\r\n    if err := config.DB.Delete(&models.User{}, id).Error; err != nil {\r\n        return err\r\n    }\r\n    return nil\r\n}"
    }
  }
}