{
  "api": {
    "config": {
      "connectDB.go": "package config\n\nimport (\n\t\"gorm.io/gorm\"\n\t\"gorm.io/driver/postgres\"\n\t\"os\"\n\t\"log\"\n\t\n)\n\nvar DB *gorm.DB\n\nfunc ConnectDB() {\n\tvar err error\n\tdsn := os.Getenv(\"DB_URL\")\n\tDB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to connect DB with error: \", err)\n\t} else {\n\t\tlog.Println(\"Connected to DB\")\n\t}\n}",
      "defaultRoles.go": "package config\n\n// import (\n// \t\"github.com/lucapierini/project-go-task_manager/config\"\n// \t\"github.com/lucapierini/project-go-task_manager/models\"\n// )\n\n// func CreateDefaultRoles(){\n// \t// Create default roles\n// \trole := models.Role{Name: \"Administrador\"}\n// \tif err := config.DB.Create(&role).Error; err != nil {\n// \t\treturn nil, err\n// \t}\n// \treturn &role, nil\n// }\n\n\n// func CreateRole(roleDto dto.RoleDto) (*models.Role, error){\n// \trole := models.Role{Name: roleDto.Name}\n// \tif err := config.DB.Create(&role).Error; err != nil {\n// \t\treturn nil, err\n// \t}\n// \treturn &role, nil\n// }",
      "loadEnvVariables.go": "package config\n\nimport (\n\t\"path/filepath\"\n\t\"log\"\n\t\"github.com/joho/godotenv\"\n)\n\nfunc LoadEnvVariables() {\n\t// Load environment variables\n\tenvPath := filepath.Join(\"..\", \".env\")\n\n\terr := godotenv.Load(envPath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file\")\n\t}\n}",
      "syncDB.go": "package config\n\nimport \"github.com/lucapierini/project-go-task_manager/models\"\n\nfunc SyncDB() {\n\t// DB.AutoMigrate(&models.Project{})\n\t// DB.AutoMigrate(&models.Task{})\n\tDB.AutoMigrate(&models.User{})\n\tDB.AutoMigrate(&models.Role{})\n}"
    },
    "dto": {
      "LoginDto.go": "package dto\n\ntype LoginDto struct {\n    Email    string `json:\"email\" binding:\"required,email\"`\n    Password string `json:\"password\" binding:\"required\"`\n}",
      "ProjectDto.go": "package dto\n\nimport (\n\n)\n\ntype ProjectDto struct {\n\tName string `json:\"name\" binding:\"required\"`\n\tBudget float64 `json:\"budget\" binding:\"required\"`\n\tOwnerID uint `json:\"owner_id\" binding:\"required\"`\n\tUsersIds []uint `json:\"users_ids\"`\n\tTasksIds []uint `json:\"tasks_ids\"`\n}",
      "RoleDto.go": "package dto\n\ntype RoleDto struct {\n\tName string `json:\"name\" binding:\"required\"`\n}",
      "UserDto.go": "package dto\n\ntype UserDto struct {\n    Username string `json:\"username\" binding:\"required\"`\n    Email    string `json:\"email\" binding:\"required,email\"`\n    Password string `json:\"password\" binding:\"required,min=6\"`\n    RoleIds  []uint `json:\"role_ids\"`\n}"
    },
    "go.mod": "module github.com/lucapierini/project-go-task_manager\n\ngo 1.23.1\n\nrequire (\n\tgithub.com/gin-gonic/gin v1.10.0\n\tgithub.com/golang-jwt/jwt v3.2.2+incompatible\n\tgithub.com/joho/godotenv v1.5.1\n\tgolang.org/x/crypto v0.23.0\n\tgorm.io/driver/postgres v1.5.11\n\tgorm.io/gorm v1.25.12\n)\n\nrequire (\n\tgithub.com/bytedance/sonic v1.11.6 // indirect\n\tgithub.com/bytedance/sonic/loader v0.1.1 // indirect\n\tgithub.com/cloudwego/base64x v0.1.4 // indirect\n\tgithub.com/cloudwego/iasm v0.2.0 // indirect\n\tgithub.com/gabriel-vasile/mimetype v1.4.3 // indirect\n\tgithub.com/gin-contrib/sse v0.1.0 // indirect\n\tgithub.com/go-playground/locales v0.14.1 // indirect\n\tgithub.com/go-playground/universal-translator v0.18.1 // indirect\n\tgithub.com/go-playground/validator/v10 v10.20.0 // indirect\n\tgithub.com/goccy/go-json v0.10.2 // indirect\n\tgithub.com/jackc/pgpassfile v1.0.0 // indirect\n\tgithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect\n\tgithub.com/jackc/pgx/v5 v5.5.5 // indirect\n\tgithub.com/jackc/puddle/v2 v2.2.1 // indirect\n\tgithub.com/jinzhu/inflection v1.0.0 // indirect\n\tgithub.com/jinzhu/now v1.1.5 // indirect\n\tgithub.com/json-iterator/go v1.1.12 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.7 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/leodido/go-urn v1.4.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n\tgithub.com/modern-go/reflect2 v1.0.2 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.2.2 // indirect\n\tgithub.com/rogpeppe/go-internal v1.13.1 // indirect\n\tgithub.com/twitchyliquid64/golang-asm v0.15.1 // indirect\n\tgithub.com/ugorji/go/codec v1.2.12 // indirect\n\tgolang.org/x/arch v0.8.0 // indirect\n\tgolang.org/x/net v0.25.0 // indirect\n\tgolang.org/x/sync v0.1.0 // indirect\n\tgolang.org/x/sys v0.21.0 // indirect\n\tgolang.org/x/text v0.15.0 // indirect\n\tgoogle.golang.org/protobuf v1.34.1 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n",
    "go.sum": "github.com/bytedance/sonic v1.11.6 h1:oUp34TzMlL+OY1OUWxHqsdkgC/Zfc85zGqw9siXjrc0=\ngithub.com/bytedance/sonic v1.11.6/go.mod h1:LysEHSvpvDySVdC2f87zGWf6CIKJcAvqab1ZaiQtds4=\ngithub.com/bytedance/sonic/loader v0.1.1 h1:c+e5Pt1k/cy5wMveRDyk2X4B9hF4g7an8N3zCYjJFNM=\ngithub.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=\ngithub.com/cloudwego/base64x v0.1.4 h1:jwCgWpFanWmN8xoIUHa2rtzmkd5J2plF/dnLS6Xd/0Y=\ngithub.com/cloudwego/base64x v0.1.4/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=\ngithub.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=\ngithub.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=\ngithub.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=\ngithub.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=\ngithub.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=\ngithub.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=\ngithub.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=\ngithub.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=\ngithub.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=\ngithub.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=\ngithub.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=\ngithub.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=\ngithub.com/go-playground/validator/v10 v10.20.0 h1:K9ISHbSaI0lyB2eWMPJo+kOS/FBExVwjEviJTixqxL8=\ngithub.com/go-playground/validator/v10 v10.20.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=\ngithub.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=\ngithub.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=\ngithub.com/golang-jwt/jwt v3.2.2+incompatible h1:IfV12K8xAKAnZqdXVzCZ+TOjboZ2keLg81eXfW3O+oY=\ngithub.com/golang-jwt/jwt v3.2.2+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=\ngithub.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=\ngithub.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=\ngithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=\ngithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=\ngithub.com/jackc/pgx/v5 v5.5.5 h1:amBjrZVmksIdNjxGW/IiIMzxMKZFelXbUoPNb+8sjQw=\ngithub.com/jackc/pgx/v5 v5.5.5/go.mod h1:ez9gk+OAat140fv9ErkZDYFWmXLfV+++K0uAOiwgm1A=\ngithub.com/jackc/puddle/v2 v2.2.1 h1:RhxXJtFG022u4ibrCSMSiu5aOq1i77R3OHKNJj77OAk=\ngithub.com/jackc/puddle/v2 v2.2.1/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=\ngithub.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=\ngithub.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=\ngithub.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=\ngithub.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=\ngithub.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=\ngithub.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\ngithub.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=\ngithub.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=\ngithub.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=\ngithub.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=\ngithub.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=\ngithub.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/pelletier/go-toml/v2 v2.2.2 h1:aYUidT7k73Pcl9nb2gScu7NSrKCSHIDE89b3+6Wq+LM=\ngithub.com/pelletier/go-toml/v2 v2.2.2/go.mod h1:1t835xjRzz80PqgE6HHgN2JOsmgYu/h4qDAS4n929Rs=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.13.1 h1:KvO1DLK/DRN07sQ1LQKScxyZJuNnedQ5/wKSR38lUII=\ngithub.com/rogpeppe/go-internal v1.13.1/go.mod h1:uMEvuHeurkdAXX61udpOXGD/AzZDWNMNyH2VO9fmH0o=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=\ngithub.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=\ngithub.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=\ngithub.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=\ngolang.org/x/arch v0.0.0-20210923205945-b76863e36670/go.mod h1:5om86z9Hs0C8fWVUuoMHwpExlXzs5Tkyp9hOrfG7pp8=\ngolang.org/x/arch v0.8.0 h1:3wRIsP3pM4yUptoR96otTUOXI367OS0+c9eeRi9doIc=\ngolang.org/x/arch v0.8.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=\ngolang.org/x/crypto v0.23.0 h1:dIJU/v2J8Mdglj/8rJ6UUOM3Zc9zLZxVZwwxMooUSAI=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/net v0.25.0 h1:d/OCCoBEUq33pjydKrGQhw7IlUPI2Oylr+8qLx49kac=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/sync v0.1.0 h1:wsuoTGHzEhffawBOhz5CYhcrV4IdKZbEyZjBMuTp12o=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.21.0 h1:rF+pYz3DAGSQAxAu1CbC7catZg4ebC4UIeIhKxBZvws=\ngolang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.15.0 h1:h1V/4gjBv8v9cjcR6+AR5+/cIYK5N/WAgiv4xlsEtAk=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v1.34.1 h1:9ddQBjfCyZPOHPUiPxpYESBLc+T8P3E+Vo4IbKZgFWg=\ngoogle.golang.org/protobuf v1.34.1/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngorm.io/driver/postgres v1.5.11 h1:ubBVAfbKEUld/twyKZ0IYn9rSQh448EdelLYk9Mv314=\ngorm.io/driver/postgres v1.5.11/go.mod h1:DX3GReXH+3FPWGrrgffdvCk3DQ1dwDPdmbenSkweRGI=\ngorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=\ngorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=\nnullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\n",
    "handlers": {
      "RoleHandler.go": "package handlers\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\n\t\"github.com/lucapierini/project-go-task_manager/services\"\n)\n\ntype RoleHandler struct {\n\troleService services.RoleInterface\n}\n\nfunc NewRoleHandler(roleService services.RoleInterface) *RoleHandler {\n    return &RoleHandler{\n        roleService: roleService,\n    }\n}\n\nfunc (h *RoleHandler) CreateRole(c *gin.Context) {\n\tvar roleDto dto.RoleDto\n\tif err := c.ShouldBindJSON(&roleDto); err != nil {\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\n\t\treturn\n\t}\n\n\trole, err := h.roleService.CreateRole(roleDto)\n\tif err != nil {\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tc.JSON(201, role)\n}\n\nfunc (h *RoleHandler) GetRole(c *gin.Context) {\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\n\tif err != nil {\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\n\t\treturn\n\t}\n\n\trole, err := h.roleService.GetRoleById(uint(id))\n\tif err != nil {\n\t\tc.JSON(404, gin.H{\"error\": \"Role not found\"})\n\t\treturn\n\t}\n\n\tc.JSON(200, role)\n}\n\nfunc (h *RoleHandler) UpdateRole(c *gin.Context) {\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\n\tif err != nil {\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\n\t\treturn\n\t}\n\n\tvar roleDto dto.RoleDto\n\tif err := c.ShouldBindJSON(&roleDto); err != nil {\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid data\"})\n\t\treturn\n\t}\n\n\trole, err := h.roleService.UpdateRole(uint(id), roleDto)\n\tif err != nil {\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tc.JSON(200, role)\n}\n\nfunc (h *RoleHandler) DeleteRole(c *gin.Context) {\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\n\tif err != nil {\n\t\tc.JSON(400, gin.H{\"error\": \"Invalid ID\"})\n\t\treturn\n\t}\n\n\tif err := h.roleService.DeleteRole(uint(id)); err != nil {\n\t\tc.JSON(400, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tc.JSON(200, gin.H{\"message\": \"Role deleted successfully\"})\n}\n\nfunc (h *RoleHandler) ListRoles(c *gin.Context) {\n\troles, err := h.roleService.ListRoles()\n\tif err != nil {\n\t\tc.JSON(500, gin.H{\"error\": \"Failed to fetch roles\"})\n\t\treturn\n\t}\n\n\tc.JSON(200, roles)\n}",
      "TokenHandler.go": "package handlers\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/lucapierini/project-go-task_manager/models\"\n\t\"github.com/lucapierini/project-go-task_manager/services\"\n\t\"gorm.io/gorm\"\n)\n\nfunc RefreshTokenHandler(c *gin.Context) {\n\trefreshToken := c.GetHeader(\"Refresh-Token\")\n\tif refreshToken == \"\" {\n\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"refresh token required\"})\n\t\treturn\n\t}\n\n\tclaims, err := services.ValidateToken(refreshToken)\n\tif err != nil {\n\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tif claims.TokenType != \"refresh\" {\n\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid token type\"})\n\t\treturn\n\t}\n\n\t// Create a minimal user object with the claims data\n\tuser := &models.User{\n\t\tModel: gorm.Model{ID: claims.UserID},\n\t\tRoles: []models.Role{},\n\t}\n\n\tfor _, roleName := range claims.Roles {\n\t\tuser.Roles = append(user.Roles, models.Role{Name: roleName})\n\t}\n\n\t// Generate new token pair\n\ttokenPair, err := services.GenerateTokenPair(user)\n\tif err != nil {\n\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to generate new tokens\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, tokenPair)\n}",
      "UserHandler.go": "package handlers\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\n\t\"github.com/lucapierini/project-go-task_manager/services\"\n)\n\ntype UserHandler struct {\n\tuserService services.UserInterface\n}\n\nfunc NewUserHandler(userService services.UserInterface) *UserHandler {\n\treturn &UserHandler{userService: userService}\n}\n\nfunc (h *UserHandler) Register(c *gin.Context) {\n\tvar userDto dto.UserDto\n\tif err := c.ShouldBindJSON(&userDto); err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid request data\", \"details\": err.Error()})\n\t\treturn\n\t}\n\n\tuser, err := h.userService.RegisterUser(userDto)\n\tif err != nil {\n\t\tstatusCode := http.StatusInternalServerError\n\t\tswitch err {\n\t\tcase services.ErrEmailAlreadyRegistered:\n\t\t\tstatusCode = http.StatusConflict\n\t\tcase services.ErrInvalidData:\n\t\t\tstatusCode = http.StatusBadRequest\n\t\t}\n\t\tc.JSON(statusCode, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\ttokens, err := services.GenerateTokenPair(user)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to generate tokens\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusCreated, gin.H{\n\t\t\"user\":          user,\n\t\t\"access_token\":  tokens.AccessToken,\n\t\t\"refresh_token\": tokens.RefreshToken,\n\t})\n}\n\nfunc (h *UserHandler) Login(c *gin.Context) {\n\tvar loginDto dto.LoginDto\n\tif err := c.ShouldBindJSON(&loginDto); err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid credentials\"})\n\t\treturn\n\t}\n\n\tuser, err := h.userService.LoginUser(loginDto)\n\tif err != nil {\n\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid credentials\"})\n\t\treturn\n\t}\n\n\ttokens, err := services.GenerateTokenPair(user)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to generate tokens\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"access_token\":  tokens.AccessToken,\n\t\t\"refresh_token\": tokens.RefreshToken,\n\t\t\"user\":          user,\n\t})\n}\n\nfunc (h *UserHandler) GetUser(c *gin.Context) {\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid ID format\"})\n\t\treturn\n\t}\n\n\tuser, err := h.userService.GetUserById(uint(id))\n\tif err != nil {\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"User not found\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, user)\n}\n\nfunc (h *UserHandler) GetUserByEmail(c *gin.Context) {\n\temail := c.Query(\"email\")\n\tif email == \"\" {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Email is required\"})\n\t\treturn\n\t}\n\n\tuser, err := h.userService.GetUserByEmail(email)\n\tif err != nil {\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"User not found\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, user)\n}\n\nfunc (h *UserHandler) ListUsers(c *gin.Context) {\n\tusers, err := h.userService.ListUsers()\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to fetch users\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, users)\n}\n\nfunc (h *UserHandler) UpdateUser(c *gin.Context) {\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid ID format\"})\n\t\treturn\n\t}\n\n\tvar userDto dto.UserDto\n\tif err := c.ShouldBindJSON(&userDto); err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid request data\"})\n\t\treturn\n\t}\n\n\tuser, err := h.userService.UpdateUser(uint(id), userDto)\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, user)\n}\n\nfunc (h *UserHandler) DeleteUser(c *gin.Context) {\n\tid, err := strconv.ParseUint(c.Param(\"id\"), 10, 32)\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid ID format\"})\n\t\treturn\n\t}\n\n\tif err := h.userService.DeleteUser(uint(id)); err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to delete user\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"User deleted successfully\"})\n}"
    },
    "main.go": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/lucapierini/project-go-task_manager/config\"\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\n\t\"github.com/lucapierini/project-go-task_manager/handlers\"\n\t\"github.com/lucapierini/project-go-task_manager/middlewares\"\n\t\"github.com/lucapierini/project-go-task_manager/services\"\n)\n\nvar (\n\tuserHandler *handlers.UserHandler\n\troleHandler *handlers.RoleHandler\n)\n\nfunc init() {\n\tconfig.LoadEnvVariables()\n\tconfig.ConnectDB()\n\tconfig.SyncDB()\n\n\tuserService := services.NewUserService()\n\troleService := services.NewRoleService()\n\n\tuserHandler = handlers.NewUserHandler(userService)\n\troleHandler = handlers.NewRoleHandler(roleService)\n\n\tinitializeDefaultData(roleService, userService)\n}\n\nfunc initializeDefaultData(roleService *services.RoleService, userService *services.UserService) {\n\troles := []string{\"Administrador\", \"Lector\", \"Usuario\"}\n\tfor _, role := range roles {\n\t\tif _, err := roleService.CreateRole(dto.RoleDto{Name: role}); err != nil {\n\t\t\tlog.Printf(\"Error creating role %s: %v\\n\", role, err)\n\t\t}\n\t}\n\n\tadminUser := dto.UserDto{\n\t\tUsername: \"admin\",\n\t\tPassword: \"admin\",\n\t\tRoleIds:  []uint{1, 2},\n\t\tEmail:    \"admin@admin.com\",\n\t}\n\tif _, err := userService.RegisterUser(adminUser); err != nil {\n\t\tlog.Printf(\"Error creating admin user: %v\\n\", err)\n\t}\n}\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.Use(middlewares.CORSMiddleware())\n\n\tsetupRoutes(router)\n\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\t\n\tlog.Printf(\"Server starting on port %s\", port)\n\tif err := router.Run(\":\" + port); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}\n\nfunc setupRoutes(router *gin.Engine) {\n\tapi := router.Group(\"/api\")\n\t{\n\t\t// Public routes\n\t\tauth := api.Group(\"/auth\")\n\t\t{\n\t\t\tauth.POST(\"/register\", userHandler.Register)\n\t\t\tauth.POST(\"/login\", userHandler.Login)\n\t\t\tauth.POST(\"/refresh\", handlers.RefreshTokenHandler)\n\t\t}\n\n\t\t// Protected routes\n\t\tadmin := api.Group(\"/admin\")\n\t\tadmin.Use(middlewares.AuthMiddleware(\"Administrador\"))\n\t\t{\n\t\t\t// Roles management\n\t\t\troles := admin.Group(\"/roles\")\n\t\t\t{\n\t\t\t\troles.POST(\"/\", roleHandler.CreateRole)\n\t\t\t\troles.GET(\"/\", roleHandler.ListRoles)\n\t\t\t\troles.GET(\"/:id\", roleHandler.GetRole)\n\t\t\t\troles.PUT(\"/:id\", roleHandler.UpdateRole)\n\t\t\t\troles.DELETE(\"/:id\", roleHandler.DeleteRole)\n\t\t\t}\n\n\t\t\t// User management (admin only)\n\t\t\tusers := admin.Group(\"/users\")\n\t\t\t{\n\t\t\t\tusers.GET(\"/\", userHandler.ListUsers)\n\t\t\t\tusers.PUT(\"/:id\", userHandler.UpdateUser)\n\t\t\t\tusers.DELETE(\"/:id\", userHandler.DeleteUser)\n\t\t\t}\n\t\t}\n\n\t\t// Routes accessible by both Admin and Reader\n\t\tusers := api.Group(\"/users\")\n\t\tusers.Use(middlewares.AuthMiddleware(\"Administrador\", \"Lector\"))\n\t\t{\n\t\t\tusers.GET(\"/:id\", userHandler.GetUser)\n\t\t}\n\t}\n}",
    "middlewares": {
      "AuthMiddleware.go": "package middlewares\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/lucapierini/project-go-task_manager/services\"\n)\n\nfunc AuthMiddleware(requiredRoles ...string) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        authHeader := c.GetHeader(\"Authorization\")\n        if authHeader == \"\" {\n            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"token not provided\"})\n            return\n        }\n\n        tokenString := strings.TrimPrefix(authHeader, \"Bearer \")\n        claims, err := services.ValidateToken(tokenString)\n        if err != nil {\n            if err == services.ErrExpiredToken {\n                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"token expired\", \"code\": \"TOKEN_EXPIRED\"})\n                return\n            }\n            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid token\"})\n            return\n        }\n\n        if claims.TokenType != \"access\" {\n            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid token type\"})\n            return\n        }\n\n        if len(requiredRoles) > 0 {\n            hasRequiredRole := false\n            for _, requiredRole := range requiredRoles {\n                for _, userRole := range claims.Roles {\n                    if requiredRole == userRole {\n                        hasRequiredRole = true\n                        break\n                    }\n                }\n                if hasRequiredRole {\n                    break\n                }\n            }\n\n            if !hasRequiredRole {\n                c.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"insufficient permissions\"})\n                return\n            }\n        }\n\n        c.Set(\"userID\", claims.UserID)\n        c.Set(\"userRoles\", claims.Roles)\n        c.Next()\n    }\n}",
      "CorsMiddleware.go": "package middlewares\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc CORSMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"*\")\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS, GET, PUT\")\n\n\t\tif c.Request.Method == \"OPTIONS\" {\n\t\t\tc.AbortWithStatus(204)\n\t\t\treturn\n\t\t}\n\n\t\tc.Next()\n\t}\n}\n"
    },
    "models": {
      "Claims.go": "package models\n\nimport (\n\t\t\"github.com/golang-jwt/jwt\"\n)\n\n\ntype Claims struct {\n    UserID uint\n    Roles  []string\n    TokenType string\n    jwt.StandardClaims\n}",
      "Project.go": "package models\n\nimport \"gorm.io/gorm\"\n\ntype Project struct {\n\tgorm.Model\n\tName    string  `gorm:\"unique;not null\"`\n\tBudget  float64 `gorm:\"not null\"`\n\tOwner   User    `gorm:\"foreignKey:OwnerID\"`\n\tOwnerID uint\n\tUsers   []User `gorm:\"many2many:project_users\"`\n\tTasks   []Task `gorm:\"many2many:project_tasks\"`\n}\n\n// AddUsersToProject(projectId uint, userIds []uint) error\n// RemoveUsersFromProject(projectId uint, userIds []uint) error\n// AddTasksToProject(projectId uint, taskIds []uint) error\n// RemoveTasksFromProject(projectId uint, taskIds []uint) error\n",
      "Role.go": "package models\n\nimport \"gorm.io/gorm\"\n\ntype Role struct {\n\tgorm.Model\n\tName string `gorm:\"unique;not null\" json:\"name\"`\n\tUsers []User `gorm:\"many2many:user_roles\" json:\"users,omitempty\"`\n}\n\n",
      "Task.go": "package models\n\nimport \"gorm.io/gorm\"\n\ntype Task struct {\n\tgorm.Model\n\tName string `gorm:\"not null\"`\n\tDescription string\n\tProject Project `gorm:\"foreignKey:ProjectID\"`\n\tProjectID uint\n}",
      "TokenPair.go": "package models\n\n\ntype TokenPair struct {\n    AccessToken  string\n    RefreshToken string\n}",
      "User.go": "package models\n\nimport (\n\t\"gorm.io/gorm\"\n)\n\ntype User struct {\n\tgorm.Model\n\tUsername string `gorm:\"unique;not null\"`\n\tPassword string `gorm:\"not null\"`\n\tEmail string `gorm:\"unique;not null\"`\n\tRoles []Role `gorm:\"many2many:user_roles\"`\n}"
    },
    "services": {
      "ProjectService.go": "package services\n\nimport (\n\t\"errors\"\n\n\t\"github.com/lucapierini/project-go-task_manager/config\"\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\n\t\"github.com/lucapierini/project-go-task_manager/models\"\n)\n\ntype ProjectInterface interface {\n\tCreateProject(projectDto dto.ProjectDto) (*models.Project, error)\n\tGetProjectById(id uint) (*models.Project, error)\n\tListProjects() ([]models.Project, error)\n\tUpdateProject(id uint, projectDto dto.ProjectDto) (*models.Project, error)\n\tListProjectsByUserId(userId uint) ([]models.Project, error)\n\tDeleteProject(id uint) error\n\tAddUsersToProject(projectId uint, userIds []uint) error\n\tRemoveUsersFromProject(projectId uint, userIds []uint) error\n\tAddTasksToProject(projectId uint, taskIds []uint) error\n\tRemoveTasksFromProject(projectId uint, taskIds []uint) error\n\n}\n\ntype ProjectService struct{}\n\nfunc NewProjectService() *ProjectService {\n\treturn &ProjectService{}\n}\n\nfunc (s *ProjectService) CreateProject(projectDto dto.ProjectDto) (*models.Project, error) {\n\tvar existingProject models.Project\n\tif result := config.DB.Where(\"name = ?\", projectDto.Name).First(&existingProject); result.Error == nil {\n\t\treturn nil, errors.New(\"project already exists\")\n\t}\n\n\tproject := models.Project{\n\t\tName:    projectDto.Name,\n\t\tBudget:  projectDto.Budget,\n\t\tOwnerID: projectDto.OwnerID,\n\t}\n\n\tif len(projectDto.UsersIds) > 0 {\n\t\tvar users []models.User\n\t\tif err := config.DB.Find(&users, projectDto.UsersIds).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tproject.Users = users\n\n\t}\n\n\tif len(projectDto.TasksIds) > 0 {\n\t\tvar tasks []models.Task\n\t\tif err := config.DB.Find(&tasks, projectDto.TasksIds).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tproject.Tasks = tasks\n\t}\n\n\tif err := config.DB.Create(&project).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &project, nil\n}\n\nfunc (s *ProjectService) GetProjectById(id uint) (*models.Project, error) {\n\tvar project models.Project\n\tif result := config.DB.Preload(\"Users\").Preload(\"Tasks\").First(&project, id); result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\n\treturn &project, nil\n}\n\nfunc (s *ProjectService) ListProjects() ([]models.Project, error) {\n\tvar projects []models.Project\n\tif result := config.DB.Preload(\"Users\").Preload(\"Tasks\").Find(&projects); result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\n\treturn projects, nil\n}\n\nfunc (s *ProjectService) UpdateProject(id uint, projectDto dto.ProjectDto) (*models.Project, error) {\n\tproject, err := s.GetProjectById(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproject.Name = projectDto.Name\n\tproject.Budget = projectDto.Budget\n\n\tif len(projectDto.UsersIds) > 0 {\n\t\tvar users []models.User\n\t\tif err := config.DB.Find(&users, projectDto.UsersIds).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tproject.Users = users\n\t}\n\n\tif len(projectDto.TasksIds) > 0 {\n\t\tvar tasks []models.Task\n\t\tif err := config.DB.Find(&tasks, projectDto.TasksIds).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tproject.Tasks = tasks\n\t}\n\n\tif err := config.DB.Save(project).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn project, nil\n}\n\nfunc (s *ProjectService) ListProjectsByUserId(userId uint) ([]models.Project, error) {\n\tvar projects []models.Project\n\tif result := config.DB.Preload(\"Users\").Preload(\"Tasks\").Joins(\"Users\").Where(\"user_id = ?\", userId).Find(&projects); result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\n\treturn projects, nil\n}\n\nfunc (s *ProjectService) DeleteProject(id uint, userId uint) error {\n\tvar project models.Project\n\tif result := config.DB.First(&project, id); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\tif project.OwnerID != userId {\n\t\treturn errors.New(\"only the project owner can delete the project\")\n\t}\n\n\tif result := config.DB.Delete(&project); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}\n\nfunc (s *ProjectService) AddUsersToProject(projectId uint, userId uint, userIds []uint) error {\n\tvar project models.Project\n\tif result := config.DB.Preload(\"Users\").First(&project, projectId); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\t// Check if the user is the owner or part of the project\n\tisAuthorized := project.OwnerID == userId\n\tif !isAuthorized {\n\t\tfor _, user := range project.Users {\n\t\t\tif user.ID == userId {\n\t\t\t\tisAuthorized = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !isAuthorized {\n\t\treturn errors.New(\"user is not authorized to add users to this project\")\n\t}\n\n\tvar users []models.User\n\tif result := config.DB.Find(&users, userIds); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\tproject.Users = append(project.Users, users...)\n\n\tif result := config.DB.Save(&project); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}\n\nfunc (s *ProjectService) RemoveUsersFromProject(projectId uint, userId uint, userIds []uint) error {\n\tvar project models.Project\n\tif result := config.DB.Preload(\"Users\").First(&project, projectId); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\t// Check if the user is the owner or part of the project\n\tisAuthorized := project.OwnerID == userId\n\tif !isAuthorized {\n\t\tfor _, user := range project.Users {\n\t\t\tif user.ID == userId {\n\t\t\t\tisAuthorized = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !isAuthorized {\n\t\treturn errors.New(\"user is not authorized to remove users from this project\")\n\t}\n\n\tvar users []models.User\n\tif result := config.DB.Find(&users, userIds); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\tvar newUsers []models.User\n\tfor _, user := range project.Users {\n\t\tfound := false\n\t\tfor _, userId := range userIds {\n\t\t\tif user.ID == userId {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tnewUsers = append(newUsers, user)\n\t\t}\n\t}\n\n\tproject.Users = newUsers\n\n\tif result := config.DB.Save(&project); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}\n\nfunc (s *ProjectService) AddTasksToProject(projectId uint, taskIds []uint, userId uint) error {\n\n\tvar project models.Project\n\tif result := config.DB.Preload(\"Users\").First(&project, projectId); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\t// Check if the user is the owner or part of the project\n\tisAuthorized := project.OwnerID == userId\n\tif !isAuthorized {\n\t\tfor _, user := range project.Users {\n\t\t\tif user.ID == userId {\n\t\t\t\tisAuthorized = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !isAuthorized {\n\t\treturn errors.New(\"user is not authorized to remove users from this project\")\n\t}\n\n\tvar tasks []models.Task\n\tif result := config.DB.Find(&tasks, taskIds); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\tproject.Tasks = append(project.Tasks, tasks...)\n\n\tif result := config.DB.Save(&project); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}\n\nfunc (s *ProjectService) RemoveTasksFromProject(projectId uint, taskIds []uint, userId uint) error {\n\tvar project models.Project\n\tif result := config.DB.Preload(\"Users\").First(&project, projectId); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\t// Check if the user is the owner or part of the project\n\tisAuthorized := project.OwnerID == userId\n\tif !isAuthorized {\n\t\tfor _, user := range project.Users {\n\t\t\tif user.ID == userId {\n\t\t\t\tisAuthorized = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !isAuthorized {\n\t\treturn errors.New(\"user is not authorized to remove users from this project\")\n\t}\n\n\tvar tasks []models.Task\n\tif result := config.DB.Find(&tasks, taskIds); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\tvar newTasks []models.Task\n\tfor _, task := range project.Tasks {\n\t\tfound := false\n\t\tfor _, taskId := range taskIds {\n\t\t\tif task.ID == taskId {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tnewTasks = append(newTasks, task)\n\t\t}\n\t}\n\n\tproject.Tasks = newTasks\n\n\tif result := config.DB.Save(&project); result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}\n\n",
      "RoleService.go": "package services\n\nimport (\n\t\"github.com/lucapierini/project-go-task_manager/config\"\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\n\t\"github.com/lucapierini/project-go-task_manager/models\"\n)\n\ntype RoleInterface interface {\n\tCreateRole(roleDto dto.RoleDto) (*models.Role, error)\n\tGetRoleById(id uint) (*models.Role, error)\n\tUpdateRole(id uint, roleDto dto.RoleDto) (*models.Role, error)\n\tDeleteRole(id uint) error\n\tListRoles() ([]models.Role, error)\n\t}\n\ntype RoleService struct{}\n\nfunc NewRoleService() *RoleService {\n\treturn &RoleService{}\n}\n\nfunc (s *RoleService) CreateRole(roleDto dto.RoleDto) (*models.Role, error){\n\trole := models.Role{Name: roleDto.Name}\n\tif err := config.DB.Create(&role).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn &role, nil\n}\n\nfunc (s *RoleService) GetRoleById(id uint) (*models.Role, error){\n\tvar role models.Role\n\tif err := config.DB.First(&role, id).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn &role, nil\n}\n\nfunc (s *RoleService) UpdateRole(id uint, roleDto dto.RoleDto) (*models.Role, error){\n\trole, err := s.GetRoleById(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trole.Name = roleDto.Name\n\tif err := config.DB.Save(&role).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn role, nil\n}\n\nfunc (s *RoleService) DeleteRole(id uint) error {\n\tif err := config.DB.Delete(&models.Role{},id).Error; err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *RoleService) ListRoles()([]models.Role, error){\n\tvar roles []models.Role\n\tif err := config.DB.Find(&roles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn roles, nil\n}",
      "TokenService.go": "package services\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt\"\n\t\"github.com/lucapierini/project-go-task_manager/models\"\n)\n\n\nvar (\n    jwtSecret        = []byte(os.Getenv(\"JWT_SECRET\"))\n    ErrInvalidToken  = errors.New(\"invalid token\")\n    ErrExpiredToken  = errors.New(\"token has expired\")\n    ErrUnauthorized  = errors.New(\"unauthorized\")\n)\n\nconst (\n    accessTokenDuration  = 15 * time.Minute\n    refreshTokenDuration = 7 * 24 * time.Hour\n)\n\nfunc ValidateToken(tokenString string) (*models.Claims, error) {\n    token, err := jwt.ParseWithClaims(tokenString, &models.Claims{}, func(token *jwt.Token) (interface{}, error) {\n        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n            return nil, fmt.Errorf(\"unexpected signing method: %v\", token.Header[\"alg\"])\n        }\n        return jwtSecret, nil\n    })\n\n    if err != nil {\n        if ve, ok := err.(*jwt.ValidationError); ok {\n            if ve.Errors&jwt.ValidationErrorExpired != 0 {\n                return nil, ErrExpiredToken\n            }\n        }\n        return nil, ErrInvalidToken\n    }\n\n    claims, ok := token.Claims.(*models.Claims)\n    if !ok || !token.Valid {\n        return nil, ErrInvalidToken\n    }\n\n    return claims, nil\n}\n\nfunc GenerateTokenPair(user *models.User) (*models.TokenPair, error) {\n    // Generate access token\n    accessToken, err := generateToken(user, \"access\", accessTokenDuration)\n    if err != nil {\n        return nil, fmt.Errorf(\"error generating access token: %w\", err)\n    }\n\n    // Generate refresh token\n    refreshToken, err := generateToken(user, \"refresh\", refreshTokenDuration)\n    if err != nil {\n        return nil, fmt.Errorf(\"error generating refresh token: %w\", err)\n    }\n\n    return &models.TokenPair{\n        AccessToken:  accessToken,\n        RefreshToken: refreshToken,\n    }, nil\n}\n\nfunc generateToken(user *models.User, tokenType string, duration time.Duration) (string, error) {\n    var roleNames []string\n    for _, role := range user.Roles {\n        roleNames = append(roleNames, role.Name)\n    }\n\n    claims := models.Claims{\n        UserID: user.ID,\n        Roles:  roleNames,\n        TokenType: tokenType,\n        StandardClaims: jwt.StandardClaims{\n            ExpiresAt: time.Now().Add(duration).Unix(),\n            IssuedAt:  time.Now().Unix(),\n        },\n    }\n\n    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n    return token.SignedString(jwtSecret)\n}\n",
      "UserService.go": "package services\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/lucapierini/project-go-task_manager/config\"\n\t\"github.com/lucapierini/project-go-task_manager/dto\"\n\t\"github.com/lucapierini/project-go-task_manager/models\"\n\t// \"github.com/lucapierini/project-go-task_manager/utils\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\ntype UserInterface interface {\n    RegisterUser(userDto dto.UserDto) (*models.User, error)\n    LoginUser(loginDto dto.LoginDto) (*models.User, error)\n    GetUserById(id uint) (*models.User, error)\n    GetUserByEmail(email string) (*models.User, error)\n    ListUsers() ([]models.User, error)\n    UpdateUser(id uint, userDto dto.UserDto) (*models.User, error)\n    DeleteUser(id uint) error // Este mÃ©todo debe estar presente\n}\n\ntype UserService struct{}\n\nfunc NewUserService() *UserService {\n\treturn &UserService{}\n}\n\nvar (\n\tErrEmailAlreadyRegistered = errors.New(\"email already registered\")\n\tErrInvalidData            = errors.New(\"invalid data provided\")\n)\n\nfunc (s *UserService) RegisterUser(userDto dto.UserDto) (*models.User, error) {\n\t// Check if email already exists\n\tvar existingUser models.User\n\tif result := config.DB.Where(\"email = ?\", userDto.Email).First(&existingUser); result.Error == nil {\n\t\treturn nil, errors.New(\"email already registered\")\n\t}\n\n\t// Hash password\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create user\n\tuser := models.User{\n\t\tUsername: userDto.Username,\n\t\tEmail:    userDto.Email,\n\t\tPassword: string(hashedPassword),\n\t}\n\n\t// Add roles if specified\n\tif len(userDto.RoleIds) > 0 {\n\t\tvar roles []models.Role\n\t\tif err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.Roles = roles\n\t} else {\n\t\t// If no roles are specified, assign default role\n\t\tvar defaultRole models.Role\n\t\tif err := config.DB.First(&defaultRole, \"name = ?\", \"Usuario\").Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.Roles = []models.Role{defaultRole}\n\t}\n\n\tif err := config.DB.Create(&user).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &user, nil\n}\n\n\nfunc (s *UserService) LoginUser(loginDto dto.LoginDto) (*models.User, error) {\n\tvar user models.User\n\tif err := config.DB.Preload(\"Roles\").Where(\"email = ?\", loginDto.Email).First(&user).Error; err != nil {\n\t\tfmt.Println(\"invalid credentials\")\n\t\treturn nil, errors.New(\"invalid credentials\")\n\t}\n\n\tif err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginDto.Password)); err != nil {\n\t\tfmt.Println(\"invalid password\")\n\t\treturn nil, errors.New(\"invalid credentials\")\n\t}\n\n\treturn &user, nil\n}\n\n\nfunc (s *UserService) GetUserByEmail(email string) (*models.User, error) {\n\tvar user models.User\n\tif err := config.DB.Preload(\"Roles\").Where(\"email = ?\", email).First(&user).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn &user, nil\n}\n\nfunc (s *UserService) GetUserById(id uint) (*models.User, error) {\n    var user models.User\n    if err := config.DB.Preload(\"Roles\").Where(\"id = ?\", id).First(&user).Error; err != nil {\n        return nil, err\n    }\n    return &user, nil\n}\n\nfunc (s *UserService) UpdateUser(id uint, userDto dto.UserDto) (*models.User, error) {\n\tuser, err := s.GetUserById(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser.Username = userDto.Username\n\tuser.Email = userDto.Email\n\n\tif userDto.Password != \"\" {\n\t\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(userDto.Password), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.Password = string(hashedPassword)\n\t}\n\n\t// Update roles if specified\n\tif len(userDto.RoleIds) > 0 {\n\t\tvar roles []models.Role\n\t\tif err := config.DB.Find(&roles, userDto.RoleIds).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.Roles = roles\n\t}\n\n\tif err := config.DB.Save(user).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n\n\n\nfunc (s *UserService) ListUsers() ([]models.User, error) {\n\tvar users []models.User\n\tif err := config.DB.Preload(\"Roles\").Find(&users).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn users, nil\n}\n\nfunc (s *UserService) DeleteUser (id uint) error {\n    if err := config.DB.Delete(&models.User{}, id).Error; err != nil {\n        return err\n    }\n    return nil\n}"
    }
  }
}